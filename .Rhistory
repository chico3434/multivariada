h2
L <- sqrt(av$values)[1] %*% av$vectors[,1] %>% cbind(sqrt(av$values)[2] %*% av$vectors[,2])
L <- matrix(L, ncol = 2)
L
h2 <- matrix(L[1:5,1]^2+L[1:5,2]^2,ncol=1)
h2
princomp(R)
pr <- princomp(R)
pr
pr$loadings
av$values)[1]*av$vectors[4,1]
sqrt(av$values)[1]*av$vectors[4,1]
L
wine <- read.csv("C:/Users/chico/Downloads/wine.data", header=FALSE)
View(wine)
wine1 <- wine[,2:14]
cp <- princomp(wine, cor=T)
cp$loadings
dados <- wine[,-1]
dados
eigen(dados)
eigen(cor(dados))
princomp(dados)
pc <- princomp(dados)
pc$loadings
eigen(matrix(c(1,2,2,1),ncol=2))
matrix(c(1,2,2,1),ncol=2)
L <- matrix(L, ncol = 2)
L
L <- sqrt(av$values)[1] %*% av$vectors[,1] %>% cbind(sqrt(av$values)[2] %*% av$vectors[,2])
L <- matrix(L, ncol = 2)
L
av$vectors
av <- eigen(cor(wine1))
av
L <- sqrt(av$values)[1] %*% av$vectors[,1] %>% cbind(sqrt(av$values)[2] %*% av$vectors[,2])
L <- matrix(L, ncol = 2)
L
n <- 100000000
n/(10+n)
x.barra=99.9
n=150
x=x.barra*n
999*15
mi0 <- (x/2+200)/(n+4)
sigma2 <- 1/n+4
qnorm(0.25,mi0,sqrt(sigma2))
qnorm(0.975,mi0,sqrt(sigma2))
qnorm(0.025,mi0,sqrt(sigma2))
qnorm(0.025)
(14985/2+200)/154-1.96/sqrt(154)
(x/2+200)/(n+4)
(x/2+200)/(n+4)-1.96/sqrt(n+4)
sqqnorm(0.025,mi0,sqrt(sigma2))
qnorm(0.025,mi0,sqrt(sigma2))
qnorm(0.025,(x/2+200)/(n+4),sqrt(sigma2))
1-0.05/2
wine <- read.csv("C:/Users/chico/Downloads/wine.data", header=FALSE)
View(wine)
dados <- wine[,-1]
cor(dados)
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA)
library(dplyr)
library(ggplot2)
dados=read.csv2(file="D:/Multivariada 2023.1/T1.9.csv",T)
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA)
library(dplyr)
library(ggplot2)
dados=read.csv2("T1.9.csv",T)
dados1=dados[, -8]
(p=ncol(dados1))
head(dados1)
boxplot((dados1),col="magenta")
boxplot(scale(dados1),col="blue")
summary(dados1)
round(cov(dados1),2)
round(apply(dados1, 2, sd),2)
round(cor(dados1),2)
matcor=cor(dados1)
print(matcor, digits = 2)
plot(dados1,col="red")
pairs(dados1)
#lowCor(dados1)
#install.packages("corrplot")
library(corrplot)
## correlaçoes em azul positivas e mais escuro maiores as correlações
corrplot(cor(dados1))
corrplot(cor(dados1), order = 'AOE')
corrplot(cor(dados1), order = 'AOE', addCoef.col = 'grey')
autovalores1<- eigen(cov(dados1))
autovalores1$values
autovalores1$vectors
autovalores2<- eigen(cor(dados1))
autovalores2$values
autovalores2$vectors
dados=dados1
# COMANDO PRCOMP
cp1=prcomp(dados)            # utiliza a matriz de covariância como default
cp=prcomp(dados,scale=TRUE)  # utiliza a matriz de correlação
op <- par(mfrow = c(1,2))
plot(cp1,col="magenta")
plot(cp,col="blue")
par(op)
screeplot(cp)
plot(cp,type="lines",col="red")
summary(cp1)
summary(cp)
componentes1=cp1$x
#componentes1
cor(componentes1)
boxplot(componentes1,col="red")
biplot(cp1)
componentes=cp$x
#componentes
cor(componentes)
boxplot(componentes,col="red")
biplot(cp)
ind=(componentes-min(componentes))/(max(componentes)-min(componentes))
boxplot(componentes,col="blue")
boxplot(ind)
#install.packages("psych")
#library(psych)
### Bartlett
#cortest.bartlett(cor(dados1))
#bartlett.test(cor(dados1))
## KMO
#KMO(cor(dados1))
#**************************************************************
#Teste de Bartlett - a hipótese nula da matriz de correlação ser uma matriz identidade, isto é, avalia se os componentes fora da diagonal principal são zero. O resultado significativo indica que existem algumas relações entre as variáveis.bartlett.test(dados1)
n=nrow(dados1)
p=ncol(dados1)
R=det(cor(dados1))
X2=-((n-1)-(2*p+5)/6)*log(R);
X2
v=p*(p-1)/2
teste=qchisq(0.05,v)
X2>teste  #O modelo é apropriado para a análise fatorial pelo teste de Bartlett de esfericidade
#Teste KMO (Kaiser-Meyer-Olkin) - avalia a adequação do tamanho amostra. Varia entre 0 e 1, onde: zero indica inadequado para análise fatorial, aceitável se for maior que 0.5, recomendado acima de 0.8.
kmo = function(x)
{
x = subset(x, complete.cases(x))
r = cor(x)
r2 = r^2
i = solve(r)
d = diag(i)
p2 = (-i/sqrt(outer(d, d)))^2
diag(r2) <- diag(p2) <- 0
KMO = sum(r2)/(sum(r2)+sum(p2))
MSA = colSums(r2)/(colSums(r2)+colSums(p2))
return(list(KMO=KMO, MSA=MSA))
}
kmo(dados1)
# componentes principais
acpcor=prcomp(dados1, scale = TRUE)
summary(acpcor)
plot(1:ncol(dados1), acpcor$sdev^2, type = "b", xlab = "Componente",ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3,col="red")
k = 2
(carfat=acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat)=paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr = varimax(carfat)
carfatr
# comunalidade e variância especifica
comum=rowSums(carfat^2)
vespec=diag(cor(dados1)) - comum
estimat=cbind(comum, vespec, diag(cor(dados1)))
rownames(estimat)=colnames(dados1)
colnames(estimat)=c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid=cor(dados1) - (carfat %*% t(carfat) + diag(vespec))
resid
#factanal(x, factors, data = NULL, covmat = NULL, n.obs = NA,subset, na.action, start = NULL,scores = c("none", "regression", "Bartlett"),rotation = "varimax", control = NULL, ...)
fat=factanal(dados1,factors=2,rotation="none")
fat$loadings
unicidade=fat$uniquenesses
comunalidade_MV=1-unicidade
estimat=cbind(comum, vespec, comunalidade_MV,unicidade)
rownames(estimat)=colnames(dados1)
colnames(estimat)=c("Comunalidade_CP", "Unicidade_CP", "Comunalidade_MV","Unicidade_MV")
estimat
fat1=factanal(dados1,factors=2,rotation="varimax")
fat1$loadings
unicidade1=fat1$uniquenesses
comunalidade1_MV=1-unicidade1
estimat=cbind(comum, vespec, comunalidade_MV,unicidade,comunalidade1_MV,unicidade1)
rownames(estimat)=colnames(dados1)
colnames(estimat)=c("Comunalidade_CP", "Unicidade_CP", "Comunalidade_MV","Unicidade_MV","Comunalidade_varimax","Unicidade_varimax")
estimat
fat2=factanal(dados1,factors=2,rotation="varimax",scores="regression")
scores=fat2$scores
scores_ind=(scores-min(scores))/(max(scores)-min(scores))
boxplot(scores,col="blue")
boxplot(scores_ind,col="red")
scor=cbind(scores,scores_ind)
scor
dados=read.csv2("T1.9.csv",T)
View(dados)
dados1=dados[, -8]
(p=ncol(dados1))
head(dados1)
dad
options(scipen = 999)
autovalores1<- eigen(cov(dados1))
autovalores1$values
autovalores1$vectors
c(5.80568576, 0.65364552, 0.29988243, 0.12547749, 0.05381692, 0.03904928, 0.02244260)/sum(c(5.80568576, 0.65364552, 0.29988243, 0.12547749, 0.05381692, 0.03904928, 0.02244260))
cp$x
cp$sdev
cp$rotation
cp$rotation*dados1
cp$rotation%*%dados1
dim(dados1)
dim(cp$rotation)
dados1 %*% cp$rotation
dim(dados1)
matrix(c(dados1),ncol = 7) %*% cp$rotation
dim(cp$rotation)
matrix(c(dados1),ncol = 7) %*% matrix(c(cp$rotation),ncol=7)
matrix(c(cp$rotation),ncol=7)
matrix(c(dados1),ncol = 7)
dados1
c(dados1)
dados1[1:55,]
c(dados1[1:55,])
c(dados1[,1:7])
c(dados1[,])
#componentes1
cor(componentes1)
#componentes1
option(scipen=0)
cor(componentes1)
#componentes1
option(scipen=0)
#componentes1
options(scipen=0)
cor(componentes1)
round(cor(componentes1),4)
round(cor(componentes1),10)
0.00000000012
round(0.00000000012,10)
round(0.00000000012,12)
round(0.00000000012,8)
#| warning: false
#| message: false
library(dplyr)
library(ggplot2)
library(corrplot)
options(scipen = 999)
options(OutDec = ",")
dados <- read.csv(file="wine.data",header=F)
data <- dados[,-1]
(p <- ncol(data))
(n <- nrow(data))
head(data)
boxplot((data),col="magenta")
boxplot(scale(data),col="blue")
summary(data)
knitr::kable(cov(data), digits = 2, caption = "Matriz de variância e covariância")
#knitr::kable(round(cor(data),2))
knitr::kable(cor(data), digits = 2, caption = "Matriz de correlação")
plot(data, col="red")
#pairs(data)
corrplot(cor(data), method = "color", addCoef.col = "black", number.cex = 0.7)
corrplot(cor(data), order = 'AOE', addCoef.col = "black", number.cex = 0.7, method = "color")
autovalores1 <- eigen(cov(data))
knitr::kable(col.names = "Autovalores",autovalores1$values)
knitr::kable(autovalores1$vectors, digits = 4, col.names = paste0("av",1:13))
autovalores2 <- eigen(cor(data))
knitr::kable(autovalores2$values, col.names = "Autovalores")
knitr::kable(autovalores2$vectors, digits = 4, col.names = paste0("av", 1:13))
cp1 <- prcomp(data)            # utiliza a matriz de covariância como default
cp <- prcomp(data,scale=TRUE)  # utiliza a matriz de correlação
op <- par(mfrow = c(1,2))
plot(cp1, col="magenta", main="Matriz de covariância")
plot(cp, col="blue", main="Matriz de correlação")
par(op)
plot(cp, type="lines", col="black", lwd = 2, main = "Screeplot - Matriz de correlação")
lines(c(1, 10), c(1, 1), col = "red", lwd = 2)
summary(cp1)
scp1 <- summary(cp1)
scp1$importance
scp1 <- summary(cp1)
knitr::kable(scp1$importance)
scp <- summary(cp)
knitr::kable(scp$importance)
install.packages("psych")
library(psych)
### Bartlett
#cortest.bartlett(cor(data))
bartlett.test(cor(data))
### Bartlett
cortest.bartlett(cor(data))
## KMO
KMO(cor(data))
#Teste de Bartlett - a hipótese nula da matriz de correlação ser uma matriz identidade, isto é, avalia se os componentes fora da diagonal principal são zero. O resultado significativo indica que existem algumas relações entre as variáveis.
bartlett.test(data)
cortest.bartlett(cor(data))
#Teste de Bartlett - a hipótese nula da matriz de correlação ser uma matriz identidade, isto é, avalia se os componentes fora da diagonal principal são zero. O resultado significativo indica que existem algumas relações entre as variáveis.
bartlett.test(data)
bartlett.test(cor(data))
bartlett.test(data)
cortest.bartlett(cor(data))
cortest.bartlett(cor(data), n = 13)
cortest.bartlett(cor(data), n = 178)
bartlett.test(data)
#bartlett.test(data)
cortest.bartlett(cor(data), n = 178)
options(scipen = 0)
cortest.bartlett(cor(data), n = 178)
cor(data)
#Teste KMO (Kaiser-Meyer-Olkin) - avalia a adequação do tamanho amostra. Varia entre 0 e 1, onde: zero indica inadequado para análise fatorial, aceitável se for maior que 0.5, recomendado acima de 0.8.
kmo = function(x)
{
x = subset(x, complete.cases(x))
r = cor(x)
r2 = r^2
i = solve(r)
d = diag(i)
p2 = (-i/sqrt(outer(d, d)))^2
diag(r2) <- diag(p2) <- 0
KMO = sum(r2)/(sum(r2)+sum(p2))
MSA = colSums(r2)/(colSums(r2)+colSums(p2))
return(list(KMO=KMO, MSA=MSA))
}
kmo(data)
# componentes principais
acpcor=prcomp(data, scale = TRUE)
summary(acpcor)
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente",ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3,col="red")
k = 2
(carfat=acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat)=paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr = varimax(carfat)
carfatr
# comunalidade e variância especifica
comum=rowSums(carfat^2)
vespec=diag(cor(data)) - comum
estimat=cbind(comum, vespec, diag(cor(data)))
rownames(estimat)=colnames(data)
colnames(estimat)=c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid=cor(data) - (carfat %*% t(carfat) + diag(vespec))
resid
#| warning: false
#| message: false
library(dplyr)
library(ggplot2)
library(corrplot)
library(psych)
options(scipen = 999)
options(OutDec = ",")
knitr::kable(summary(data))
# componentes principais
acpcor <- prcomp(data, scale = TRUE)
summary(acpcor)
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
k <-  2
(carfat <- acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat) <- paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr = varimax(carfat)
carfatr
# comunalidade e variância especifica
comum=rowSums(carfat^2)
vespec=diag(cor(data)) - comum
estimat=cbind(comum, vespec, diag(cor(data)))
rownames(estimat)=colnames(data)
colnames(estimat)=c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid=cor(data) - (carfat %*% t(carfat) + diag(vespec))
resid
# componentes principais
acpcor <- prcomp(data, scale = TRUE)
summary(acpcor)
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
k <-  2
(carfat <- acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat) <- paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr <- varimax(carfat)
carfatr
# comunalidade e variância especifica
comum <- rowSums(carfat^2)
vespec <- diag(cor(data)) - comum
estimat <- cbind(comum, vespec, diag(cor(data)))
rownames(estimat) <- colnames(data)
colnames(estimat) <- c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid <- cor(data) - (carfat %*% t(carfat) + diag(vespec))
resid
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
lines(c(0,13), c(1,1), col = "black")
line(c(0,13), c(1,1), col = "black")
line(c(0,13), c(1,1), "black")
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
line(c(0,13), c(1,1), "black")
lines(c(0,13), c(1,1), "black")
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
lines(c(1,13), c(1,1), col = "black", lwd = 2)
acpcor <- prcomp(data, scale = TRUE)
scp <- summary(acpcor)
knitr::kable(scp$importance)
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
lines(c(1,13), c(1,1), col = "black", lwd = 2)
k <- 3
(carfat <- acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat) <- paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr <- varimax(carfat)
carfatr
# comunalidade e variância especifica
comum <- rowSums(carfat^2)
vespec <- diag(cor(data)) - comum
estimat <- cbind(comum, vespec, diag(cor(data)))
rownames(estimat) <- colnames(data)
colnames(estimat) <- c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid <- cor(data) - (carfat %*% t(carfat) + diag(vespec))
resid
acpcor <- prcomp(data, scale = TRUE)
scp <- summary(acpcor)
knitr::kable(scp$importance)
plot(1:ncol(data), acpcor$sdev^2, type = "b", xlab = "Componente", ylab = "Variância", pch = 20, cex.axis = 1.3, cex.lab = 1.3, col="red")
lines(c(1,13), c(1,1), col = "black", lwd = 1)
k <- 3
(carfat <- acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat) <- paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr <- varimax(carfat)
carfatr
# comunalidade e variância especifica
comum <- rowSums(carfat^2)
vespec <- diag(cor(data)) - comum
estimat <- cbind(comum, vespec, diag(cor(data)))
rownames(estimat) <- colnames(data)
colnames(estimat) <- c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid <- cor(data) - (carfat %*% t(carfat) + diag(vespec))
resid
k <- 3
(carfat <- acpcor$rotation[, 1:k] %*% diag(acpcor$sdev[1:k]))
colnames(carfat) <- paste("Fator", 1:k, sep = " ")
carfat
# rotação dos fatores
carfatr <- varimax(carfat)
carfatr
# comunalidade e variância especifica
comum <- rowSums(carfat^2)
vespec <- diag(cor(data)) - comum
estimat <- cbind(comum, vespec, diag(cor(data)))
rownames(estimat) <- colnames(data)
colnames(estimat) <- c("Comunalidade", "Variância única", "Variância")
estimat
# matriz de residuos
resid <- cor(data) - (carfat %*% t(carfat) + diag(vespec))
resid
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
cache=FALSE,
prompt=FALSE,
tidy=TRUE,
comment=NA)
library(ggplot2)
library(ggpubr)
library(DT)
library(mclust)
library(factoextra)
library(glue)
library(cluster)
library(fpc)
library(ape)
library(purrr)
library(mclust)
wine <- read.csv("wine.data", header = FALSE)
dados <- wine[,-1]
dados.padronizados <- scale(dados)
datatable(dados, caption = "Base de dados")
boxplot(dados)
boxplot(dados, col = "red")
boxplot((dados1),col="magenta")
boxplot((dados),col="magenta")
boxplot(scale(dados),col="blue")
summary(dados)
knitr::kable(cov(dados), digits = 2, caption = "Matriz de variância e covariância")
knitr::kable(cor(dados), digits = 2, caption = "Matriz de correlação")
plot(dados, col="red")
